#include<iostream>
#include<graphics.h>
using namespace std; 
//int playerscore[4] = { 500,500,500,500 }; //用于暂存步数的值
//char num1[10000]; //用于存储排行中的步数值并输出
//int map1[i][j], map2[i][j], map3[i][j].map4[i][j]//(1为墙，2为地板，3为箱子，4为目标位置，5为玩家位置）
	char PlayerInput;// 玩家输入wasd；
	int step = 0;//玩家本局走的步数
	int playerleven = 1;// ，2，3，4//玩家最高打到第多少关了
	int selectleven = 1;// 玩家在选择关卡界面选择的关卡第1，2，3，4关
	int nowleven; //玩家现在打第几关
	int moveway;// = 0，1，2，3，4
	int map1[10][10] =
	{
		{2,2,2,2,2,2,2,2,2,2},
		{2,2,2,1,1,1,1,1,2,2},
		{2,2,2,1,4,2,4,1,2,2},
		{2,1,1,2,2,2,2,2,1,2},
		{2,1,5,3,2,2,3,2,1,2},
		{2,1,1,1,2,2,1,1,1,2},
		{2,2,2,1,2,2,1,2,2,2},
		{2,2,2,1,1,1,1,2,2,2},
		{2,2,2,2,2,2,2,2,2,2},
		{2,2,2,2,2,2,2,2,2,2},
	};
	int map2[10][10] =
	{
	  {2,2,2,2,2,2,2,2,2,2},
	  {2,1,1,1,1,1,1,1,1,2},
	  {2,1,2,2,2,2,2,2,1,2},
	  {2,1,2,3,2,2,2,2,1,2},
	  {2,1,2,3,3,2,4,2,1,2},
	  {2,1,5,3,2,2,4,4,1,2},
	  {2,1,1,1,1,1,1,4,1,2},
	  {2,2,2,2,2,2,1,1,1,2},
	  {2,2,2,2,2,2,2,2,2,2},
	  {2,2,2,2,2,2,2,2,2,2},

	};
	int map3[10][10] =
	{
	{2,2,2,2,2,2,2,2,2,2},
	{2,2,1,1,2,2,2,1,1,2},
	{2,1,2,4,1,2,1,2,5,1},
	{2,1,2,2,1,1,1,2,2,1},
	{2,2,1,2,4,4,2,2,1,2},
	{2,2,1,3,3,3,2,1,2,2},
	{2,2,1,2,2,2,2,1,2,2},
	{2,2,1,1,1,1,1,1,2,2},
	{2,2,2,2,2,2,2,2,2,2},
	{2,2,2,2,2,2,2,2,2,2},

	};
	int map4[10][10] =
	{
	{2,2,2,2,2,2,2,2,2,2},
	{2,2,1,1,1,1,1,1,2,2},
	{2,1,4,2,4,2,2,4,1,2},
	{2,1,2,2,2,3,2,2,1,2},
	{2,1,1,1,2,2,1,1,1,2},
	{2,2,2,1,2,2,1,2,2,2},
	{2,1,1,2,3,3,1,2,2,2},
	{2,1,5,2,2,2,1,2,2,2},
	{2,1,1,1,1,1,1,2,2,2},
	{2,2,2,2,2,2,2,2,2,2},
	};//绘制的4个地图
	int map10[10][10] =
	{

		{2,2,2,2,2,2,2,2,2,2},
		{2,2,2,1,1,1,1,1,2,2},
		{2,2,2,1,4,2,4,1,2,2},
		{2,1,1,2,2,2,2,2,1,2},
		{2,1,5,3,2,2,3,2,1,2},
		{2,1,1,1,2,2,1,1,1,2},
		{2,2,2,1,2,2,1,2,2,2},
		{2,2,2,1,1,1,1,2,2,2},
		{2,2,2,2,2,2,2,2,2,2},
		{2,2,2,2,2,2,2,2,2,2},
	};
	int map20[10][10] =
	{
	  {2,2,2,2,2,2,2,2,2,2},
	  {2,1,1,1,1,1,1,1,1,2},
	  {2,1,2,2,2,2,2,2,1,2},
	  {2,1,2,3,2,2,2,2,1,2},
	  {2,1,2,3,3,2,4,2,1,2},
	  {2,1,5,3,2,2,4,4,1,2},
	  {2,1,1,1,1,1,1,4,1,2},
	  {2,2,2,2,2,2,1,1,1,2},
	  {2,2,2,2,2,2,2,2,2,2},
	  {2,2,2,2,2,2,2,2,2,2},

	};
	int map30[10][10] =
	{
	{2,2,2,2,2,2,2,2,2,2},
	{2,2,1,1,2,2,2,1,1,2},
	{2,1,2,4,1,2,1,2,5,1},
	{2,1,2,2,1,1,1,2,2,1},
	{2,2,1,2,4,4,2,2,1,2},
	{2,2,1,3,3,3,2,1,2,2},
	{2,2,1,2,2,2,2,1,2,2},
	{2,2,1,1,1,1,1,1,2,2},
	{2,2,2,2,2,2,2,2,2,2},
	{2,2,2,2,2,2,2,2,2,2},

	};
	int map40[10][10] =
	{
	{2,2,2,2,2,2,2,2,2,2},
	{2,2,1,1,1,1,1,1,2,2},
	{2,1,4,2,4,2,2,4,1,2},
	{2,1,2,2,2,3,2,2,1,2},
	{2,1,1,1,2,2,1,1,1,2},
	{2,2,2,1,2,2,1,2,2,2},
	{2,1,1,2,3,3,1,2,2,2},
	{2,1,5,2,2,2,1,2,2,2},
	{2,1,1,1,1,1,1,2,2,2},
	{2,2,2,2,2,2,2,2,2,2},
	};//绘制的4个地图
	void initmap();
	void Normalgame();
	void Selectgame();
	void showmap(int map[10][10]);
void ShowMenu();
	//展示菜单界面
void NormalGameStart();

	//游戏数据初始化，如step，地图
	//	展示游戏开始界面//根据PlayerLeven初始化对应关卡游戏界面。                      另外，在游戏界面又上方增加展示游戏界面增加显示步数初始为0。

void SelectGameStart();

	//游戏数据初始化，如step，地图
	//	展示游戏开始界面//根据selectleven初始化对应关卡游戏界面。另外，在游戏界面又上方增加展示游戏界面增加显示步数初始为0。
 void SelectGameLeven();
	//	展示选择游戏关卡界面
	
void ShowGameScore();
//	展示游戏排行榜界面
void ShowGameHelp();
//	展示游戏说明界面

void GetInput();
//	接收玩家输入(用kbhit和getch函数）并赋值给PlayerInput
// void GetMouse();
	//接收鼠标点击消息，并将其赋值给
void DoMouse1();
//根据鼠标在主菜单界面点击，判断进入哪个功能，并调用相应函数
 void DoMouse2();

	//根据鼠标在选择关卡界面点击位置，判断玩家如果点击的是返回，则调用主菜单函数，
	//	如果点击的是关卡，判断是否已经被解锁，如果已经被解锁，
		//将玩家选择的关卡赋值给selectleven，
//并调用SelectGameStart（）；

 void DoMouse3();
//根据鼠标在游戏界面点击位置，判断是否点击返回，若是，调用主菜单函数
void DoMouse4();

	//根据鼠标在排行榜界面点击位置，判断是否点击返回，若是，调用主菜单函数
void DoMouse5();

	//根据鼠标在游戏说明界面点击，判断是否点击返回，若是，调用主菜单函数
//sfun6: 绘制游戏地图，（给上面全局变量四个map数组赋值）1为墙，2为地板，3为箱子，4为目标位置，5为玩家位置）
//可以把箱子多放几个，不然显得太容易, 并将每一关箱子数赋值给box数组以及goal数组，



void FindPlayer(int map[10][10]);
	//不通关卡，通过遍历数组，寻找玩家位置，并赋值给playersize；
void ShowStep();
void PlayerMusic();
void CloseMusic();
void DefineMove(int map[10][10]);
	/*判断玩家移动是否合法，即向wasd方向移动是否为墙，如果是墙，令moveway = 0，如果不是，
		判断是否为地板，是的话令moveway = 1，是否为箱子，如果是箱子，是否能推动，
		如果不能推动，令moveway = 2，如果能推动，令moveway = 3，
		如果人下一步走的是目标位置，令moveway = 4，
}*/
void Move(int map[10][10]);
	/*根据DefineMove中的说明，即根据moveway的值进行相应操作，
		如果是0，函数之间返回结束，
		如果是1，判断是正常走还是从目标位置走到正常地板，改变playersize对应横纵纵标的值，
		并将人物图片与地板图片换位置或者更新目标位置图片与人位置图片，step值加1，
		如果是2，函数之间返回结束，
		如果是3，判断箱子是否本身就处在目标位置（通过原map的备份map10[][], map20[]][, map30[][], map40[][]判断），如果是，是否将箱子推出目标位置，推出的话，对应剩余箱子数goal[nowleven]++，
		或者下一步仍然是目标位置，
		更新map中的值，以及对应图片位置调换，
		如果不是，判断是否推到目标位置，若是，goal[nowleven]--; (剩余箱子数），更新map，更新图片，
			如果不是，改变map值，，
			最后改变playersize对应横纵左标的值，

			最后，step++
			如果是4，改变map值与人物位置，*/


void DefineSuccess();
//{
	//判断是否成功，(通过判断goal[nowleven]是否为0），
		//若成功，{ 调用ReNewScore()函数，如果[nowleven等于playerleven且playerleven <= 3的话，执行playerleven++，和
		//selectleven++,如果selectleven <= 4，调用SelectGameStart()函数； }
		//若未成功，return。

void ReNewScore();

	//更新排行榜（通过比较本次步数与存档中记录的值，进行更新）
//sfun13 设置各界面参数（最上面的struct）
/*地图目的地
int map1
int return_x1; 300
int return_y1; 250
int return_length1; 50
int return_width1;   50(300.250.350.300)
int return_x2; 400
int return_y2; 250
int return_length2; 50
int return_width2; 50(400.250.450.300)

int map2
int return_x1; 250
int return_y1; 200
int return_length1; 50
int return_width1; 50(250.200.300.250)
int return_x2; 250
int return_y2; 250
int return_length2; 50
int return_width2; 50(250.250.300.300)
int return_x3; 250
int return_y3; 300
int return_length3; 50
int return_width3; 50
int return_x4; 250
int return_y4; 350
int return_length4; 50
int return_width4; 50(250.350.300.400)

int map3
int return_x1; 250
int return_y1; 200
int return_length1; 50
int return_width1; 50(250.200.300.250)
int return_x2; 300
int return_y2; 300
int return_length2; 50
int return_width2; 50(300.300.350.350)
int return_x3; 350
int return_y3; 300
int return_length3; 50
int return_width3; 50 (350.300.400.350)

int map4  int return_x1; 250
int return_y1; 200
int return_length1; 50
int return_width1; 50 (250.200.300.250)
int return_x2; 300
int return_y2; 250
int return_length2; 50
int return_width2; 50(300.250.350.300)
int return_x3; 450
int return_y3; 200
int return_length3; 50
int return_width3; 50(450.250.500.300)*/