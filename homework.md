# 贪心
## 贪心选择性质：
### 自顶向下，当作出一个贪心选择，不必事先分析构成该贪心选择的子问题的解，而是直接作出贪心选择（区别于动态规划）
  贪心选择可能依赖于之前作出的选择，但绝对不会依赖于将来要作出的选择和子问题的解
输入单增预处理，可以改进贪心算法，如果不对输入做单调预处理，也能运用贪心算法，但代价是，每次递归或迭代时，都必须扫描所有的输入集，增加了工作量
最优子结构：子问题的最优解和贪心选择合并生成原问题的最优解
判断关键点：
  假设先直接做出首次贪心选择（不必事先分析构成该贪心选择的子问题的解），将问题分解为贪心选择的解和余下的子问题的最优解
考量在贪心选择的子问题中，该贪心选择是不是该子问题的最优解，也即是否存在比贪心选择更好的最优解；
如果该贪心选择是最优解，即可以用来贪心选择

实际应用中，数据结构千变万化，但都离不开这些基本的数据结构，复杂度最终由一种数据结构的底层实现决定
List是顺序表，顺序表是一种抽象的数据结构，其底层实现有两种：数组和链表。数组实现要求必须内存空间连续，而链表的内存区域是通过指针连接起来的，在随机访问方面，数组实现优于链表实现，但插入删除之类的，链表实现要优于数组
例如顺序表List有两种实现，数组实现ArrayList和链表实现LinkedList，而Set也有HashSet和TreeSet两种实现，分别基于散列表和红黑树，复杂度分析要基于这两种基本的数据结构分析
以HashMap为例，其内部以散列表为底层实现，每个元素是一个Entry类，而每个Entry是一个key关联一个value，而Hash值根据key值计算，key值一定不会重复，而hashcode值却可能重复而导致冲突
搜索操作，对用java中的contain等操作，本质上是根据关键字搜索对应的元素
而随机访问操作，对应java中的get操作，而对于数组则是A[i]操作，后者复杂度是o(1),而前者往往要慢一些
Key是元素的唯一标识，以下讨论中，假设关键字互不相同，而下标则是顺序标记，类似于数组的下标
### 数组：数组也是一种数据结构，但其本身不具备集合的基本操作，例如插入和删除，因为其长度是固定的，因此数组不是集合
由于采用直接寻址，随机访问一个元素时间复杂度为(1)；搜索一个元素的复杂度为O(n)
对于已经排好序的数组来说，随机访问的复杂度不变；但搜索一个元素复杂度为O(lgn)
除数组外，别的数据结构通常情况下，不能在O(1)时间内随机访问任何一个元素，例如链表的get操作，时间复杂度为O(n),因为其每次必须从head指针开始，向后移动；因此集合的随机访问性能不如数组
堆：也叫做二叉堆，本质上是一个数组，但可以看作一个近似的完全二叉树，但不是完全二叉树
最大堆：用于堆排序，父节点大于两个子节点，但左右节点的顺序没有要求，要还原数组，只需要从最上层开始，从左往右开始，依次排序，最终将会得到数组；按照java的起始位置0为参考，如果已知某节点为i，那么其左节点为2i+1，右节点为2i+2
最小堆：用于构造优先队列，父节点小于两个子节点，但左右节点的顺序没有要求
### 优先队列：
优先队列可以借助最大堆或最小堆来实现，分为最大优先队列和最小优先队列
最大优先队列的应用场合例如任务调度，数组下标可以作为优先级或Key值句柄
最小优先队列应用在按照时间顺序的事件驱动等场合
决策树模型：在分析四种比较排序中，借助决策树模型，可以得出最坏情况下界为O(nlgn)，决策树模型是一颗完全二叉树


### 栈：也称为堆栈，这里以数组实现为例；而单独的“堆”有两层含义，一种是垃圾回收机制中的由程序员分配的内存块，另一种是(二叉)堆
其具有三种基本操作，POP,PUSH,STACK-EMPTY（是否为空栈），三种复杂度都是O(1)
另有上溢和下溢两种错误提示，分别是POP超出栈大小和对空栈进行POP操作
队列：这里以数组实现为例，以一个长度为n的数组为例，首尾相邻构成一个环形结构。Q.head指向队首元素，而Q.tail指向下一个元素将要插入的位置
如果队列未满，则Q.tail总是指向一个空的位置；如果队列已满，则Q.tail和队首元素Q.head重合。
队列包含两个基本操作，入队和出队，复杂度均为O(1)
当采用非数组实现的时候，入队出队操作对应于底层实现的插入和删除操作，复杂度仍然为O(1)
链表：类似于数组类型，以双向链表为例，数组的顺序由下标决定，而链表的顺序则是由各个子对象元素里的指针决定的
每个元素都是一个子对象，每个子对象包含一个pre和next指针，前者指向前驱元素，后者指向后继元素；而链表内部有一个head指针，它属于链表对象本身而非元素对象，head指针指向首元素，然而首元素的pre始终为null，而且尾元素的next始终为null；
如果head指针为null，则链表此时为空
链表可以按照插入顺序维护数据结构，而java中的通用的HashSet集合则不会保存插入顺序，而其变体如果采用链式结构，则可以赋予Set集合的按次序排列
链表的变体包括：单链接（不含pre），循环（首尾相互指向），排序，非排序则表示插入的顺序可以在插入时按照key排序而动态调整
链表和数组的对比：链表在插入和删除时具有更好的性能，而数组对于随机访问具有更好的性能。这是由于如果超出数组边界，则需要创建新数组，并重新赋值，因此复杂度更高
链表中key的含义是元素对象某个属性值，而非链表的顺序标号，链表的顺序由指针来维护
从链表中依据key值，搜索某个元素，复杂度为O(n)；而删除指定的某个元素，复杂度为O(1)；插入一个元素，复杂度仍然为O(1)；随机访问某个元素即get操作的复杂度为O(n)
哨兵：加入哨兵作为首元素的链表相当于一个循环双向链表，也即简化了首尾边界处理，删除了head指针，用L.nil代替head指针，该指针永远指向哨兵元素，将首尾用哨兵元素相连接，统一简化了各个基本操作；哨兵的加入，简化了编程，也在常数系数级别上降低了复杂度，然而，当存在很多短链表的时候，浪费了空间
指针和对象：有些编程语言不支持对象或指针，这就提供指针和对象数据结构的实现
多数组同一下标构成一个对象，分别是pre，next，key，其中pre和next是整型数组，其元素值代表的下标可以指向另一个对象
单数组用三个连续的元素表示一个对象，分别是key，next，pre，next和pre的值指向别的元素key所在的位置，按照0,1,2的偏移量可以找到其余的对象属性
有根树：借助链式结构可以实现树的数据类型
### 二叉树：每个父节点最多拥有两个子节点
分支无限制的有根树：采用左孩子右兄弟表示法（O(n)存储空间），每个元素内部仍然只有两个指针，一个指向该父节点的孩子，另一个指向该父节点的相邻的平级兄弟节点
直接寻址表（容量非动态，易造成空间浪费）
把指向对象的指针存放在一个数组中，数组中存放对象的指针，而数组的下标即关键字，这个数组称为直接寻址表。直接寻址表本质上是一个数组，用空间换取效率，提高了性能
当关键字全域不是很大的时候，创建一个与关键字全域相同大小的的直接寻址表，当进行随机访问的时候，采用直接寻址，只需要O(1)复杂度，就可以找到对象的指针，进而返回该对象；当进行搜索操作的时候，复杂度为O(1)，因为key值与下标相同，因此实质上与随机访问操作是一样的
某些情况下，可以直接在数组存储表中，存储对象而非对象的指针，可以进一步在常数级别上提高效率，但复杂度仍然为O(1)
缺点：直接寻址表是一个固定长度的数组，无法存储过多的对象，灵活性受限；而且当所存储的对象数量小于直接寻址表的大小时，会造成空间的极大浪费
### 散列表：
散列表解决了直接寻址表的缺陷，将散列表的大小控制在O(K)范围内，K是所存储的元素总数；然而降低了搜索性能，尽管如此，其搜索性能仍然是优秀的
散列表以散列值为下标，本质上是一个数组，散列值根据key值经过散列函数算出，如果出现了重复，有相应的解决冲突的方案
散列表是数组概念的推广，其搜索功能的平均时间是O(1),最坏运行时间是O(n)；插入和删除操作复杂度为O(1)
对于完全散列，由于对元素采用静态储存，即一旦存入后不再改变，因此提高了性能，其搜索操作的最坏运行时间也是O(1)
散列表类似于直接寻址表，但其下标由散列函数来计算，即下标
k = h(key)

T[k]即可取出对象的指针，进而返回对象；

解决冲突：
基本概述：
散列表的大小一般会小于关键字全域
如果输入规模大于散列表大小，则一定会产生冲突
即使是输入规模小于散列表大小，仍然由于散列函数自身的原因，仍然可能会对不同的key产生相同的下标，造成冲突
开放寻址法对于删除的操作支持不友好，因此链表法更为常见
链表法：散列表的元素通过链表形式来储存，可以解决冲突问题，此外也不会影响搜索，因为关键字互不相同，只是散列函数产生的下标相同，因此仍然可以用key在链表中搜索对应的元素；采用链接法后，查找的复杂度变为O(n)，然而其平均运行时间仍然为O(1)；而插入和删除的复杂度不变仍然为O(1)
开放寻址法：开放寻址法的容量上限有限制，不比链表法；然而，其对于每种关键字，用关键字key作为参数，生成对应序列的特定排列，不会出现下标相同的情况，从左往右依次储存，提高了检索效率，直到整个数组被充满，以至于不能够继续增加元素；当装载因子n/m为一个常数的时候，插入和检索的复杂度均为O(1)，因为插入和删除隐含检索操作，而检索操作的复杂度为O(1),总体上优于链表法；由于删除操作产生的标识会影响复杂度衡量，因此，不考虑删除的复杂度
完全散列：该数据结构一旦存入后，不再能够删除，例如CD-ROM等介质；采用完全散列的技术，插入和检索的复杂度均为O(1)
### 二叉树：
基本概述：
对于完全二叉树，高度为lgn
对于非完全二叉树，最大高度为线性链n
二叉树的每个节点除了key值外，还包含三个重要属性：p、left、right，分别指向父节点、左节点和右节点，而某些题目会省略父节点，需注意；然而，传统意义上的二叉树，必须包含三大属性
重要概念：深度h，也称高度h，每个小分支的长度为1深度，因此，只有根节点或者没有根节点（后者为空树）深度为0
二叉树的分类：（3、4为常用考点）
满二叉树：所有的非空节点，都有左右两个子节点，空节点不必再有子节点
完全二叉树：所有叶的深度均相同，也即最后一层不存在空节点；如果完全二叉树的最后一层不满，尽管不是完全二叉树，但高度仍为lgn的向下取整
一般二叉树：
左中右的节点大小顺序无限制
元素key值可以相同，也即可以包含相同元素
### 二叉搜索树：
所有节点的key值互不相同
左子树中的所有节点<父节点<右子树中的所有节点
注意这里是大于、小于号，不包括相等的情况
二叉树的三大遍历方法：区分依据是左右子树相对根节点遍历的先后顺序
若根节点输出位于左右子树之前，为前序遍历(preorder)
若根节点输出位于左右子树之间，为中序遍历(inorder)
若根节点输出位于左右子树之后，为后序遍历(postorder)
常用中序遍历，三种遍历方式的复杂度均为O(n)
关于左右子树的扫描顺序，一定是从左往右，即使是后序遍历也是一样的，区别只有根节点的位置，左右子树不变
搜索、最小值、最大值、前驱和后继操作复杂度均为O(h),h为树的高度；对于完全二叉树，h = lgn，因此复杂度为O(lgh)
插入和删除操作的复杂度为O(h)，同理，对于完全二叉树为O(lgn)
仅通过插入操作，随机构建二叉树的期望高度为lgn
### 红黑树：
众多平衡树中的一种，红黑树同时也是一种二叉树，但比起传统的二叉树性能更优秀
红黑树的最大高度为2lg(n+1)，这一点优于二叉树，因为二叉树最大高度为n
红黑树的集合基本操作的复杂度降为O(lgn)，而二叉树是O(h)
在java中的应用场合，例如TreeMap底层采用红黑树实现；而HashMap底层采用散列表来实现
就搜索功能来看，后者性能更优秀；
然而由于TreeMap是有序储存，而HashMap是无序储存，因此，如果要顺序遍历，TreeMap性能更好
算法总结：
### 图算法：
输入规模：结点数V和边数E，例如O(VE)，运行效率和两个参数有关，而不是非图算法时的n
G.V和G.E表示图形G的结点集合和边集合
图的表示：
邻接链表和邻接矩阵
有向图：边是单向的，反过来相当于边不存在，因此有向图最大的边数会少于无向图
无向图：边是没有方向的，因此正反方向都存在边，因此无向图的边数最大值会比有向图多
对于邻接矩阵和邻接链表来说，两者都可以表示无向图和有向图
邻接链表：
特点：适合大多数情况，如边数较少，稀疏图，这里的参考点是E<<V^2
构成细节：先为点从0开始标号，邻接链表实质上是一个数组，每个元素是一个单向链表(当然，也可以增加父节点变为双向链表)，包含了所有与当前点有邻接边的所有点，顺序随意
权重：链表中增加权重属性即可
邻接矩阵：
特点：适合稠密图，E≈V^2，如果需要判断两个结点之间是否有边相连，也需要邻接矩阵，此外，由于邻接矩阵存储空间占用多，但使用简单，因此在图形规模不是很大时，采用邻接矩阵是个不错的选择
详细细节：先为点从0开始标号，创建一个v*v的矩阵，对应的点之间有边时，则相应的值为1，没有则为0
权重：矩阵中的值就是权重的值，当然，没有边相当于权重为0，那么相应的元素值也是0，此外，oo无穷大也可以表示无边
广度优先搜索DFS(depth first search)：
特点：每次都要扫描当前结点的所有子节点，且如果第一个被扫描的结点为s，那么扫描完成后，每个结点的d属性一定是原结点到本结点的最短路径长度
算法设计：黑色结点代表已经被扫描过的节点，灰色代表刚刚被扫描过，灰色结点会被放入队列，一个点的所有子节点都被扫描后，该结点由灰色变为黑色，白色节点表示完全没有被扫描过，每个节点至多只能被扫描一次,每个节点都有一个父节点π指向其父节点
广度优先树：广度优先搜索完之后，包含所有的π点、叶节点和树边构成广度优先树，广度优先树构成的图叫做前驱子图，树中的边称为树边，树会包含所有的结点，但边却不一定
深度优先搜索BFS（breadth first search）：
特点：每次直驱向深入，直到没有节点可以寻找，然后返回上一级节点，最终没有可退的地方时，扫描结束
数学知识
排列组合
全排列：n中挑k个全排列，也即顺序相关；计算方法是，n!/(n-k)!；例如，5个中挑2个全排列，5*4=20
组合：n中挑k个组合，也即顺序无关；计算方法是，n!/((n-k)!k!)；例如，5个中挑2个组合，5*4/2=10
