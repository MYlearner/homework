# 二叉搜索树
## 关于树：

节点是其本身的祖先和孩子
从根节点r到节点x的简单路径上的所有节点y都是x的祖先，如果y≠x，则称y是x的真祖先。（这点同数学上的真子集类似），真后代类似。
节点x的孩子数目等于节点x的度
根节点r到节点x的条简单路径的长度即为x在有根树T中的深度。
节点在树中的高度是指从该节点到叶节点的一条简单路径上边的数目。树的高度也等于树中点的最大深度。
如果从根r到节点x的简单路径上最后一条边是（y,x）则称y是x的双亲，x是y的孩子。
如果两个节点有相同的双亲，则他们是兄弟。
没有孩子的节点称为叶节点（或外部节点），一个非叶节点是内部节点。
有序树：是一颗有根树（是一个自由树，其顶点中存在一个与其他顶点不同的顶点），每个节点的孩子是有序的，给孩子标号，这是第一个孩子，那是第二个孩子...
自由树：是一个连通的、无环的无向图。称一个可能不连通的无向无环图为森林。
满二叉树：每个节点是叶节点或者度为2
一个高度为h的完全k叉树的内部节点个数为：k^h-1/(k-1) 完全二叉树有2^h-1个内部节点。
完全k叉树：所有叶节点深度相同，且所有内部节点度为k的k叉树（所有节点有k个叉）
注意：《算导》的完全二叉树和满二叉树跟《大话数据结构》里的二者定义完全不同，具体以哪个为准，暂不纠结，哪位朋友知道的，可以告知一下

## 简介
二叉搜索树的性质：x是一个节点，则其左（右）子树任意节点.key 分别≤（≥）x.key

遍历：
中序遍历（inorder tree walk）子树根的关键字位于左右子树的关键字之间。
前序遍历（preorder tree walk）子树根的关键字位于左右子树的关键字之前。
后序遍历（postorder tree walk）子树根的关键字位于左右子树的关键字之后。
INORDER-TREE-WALK

这里区分一下二叉搜索树和最大堆，相同点：比较都是针对所有节点而言，不同点：二叉搜索树，节点左子树值均小于该节点的值，右子树值均小于该节点的值；最大堆：节点值大于所有孩子的值。

### 查找
O(h)，h是这棵树的高度，下面五种操作都是这个复杂度
两种写法：递归和while
递归写法
while写法

最大值和最小值：分别一直查左子树（右子树）即可
最小值

后继（successor）和前驱（predecessor）：
后继：两种情况，如果x的右子树不为空，则右子树中的最小值就是x的后继； 反之，一直找x的双亲节点，直到x是y的左子树为止。
后继节点

### 插入和删除
插入和删除会引起由二叉搜索树表示的动态集合的变化，一定要修改数据结构来反映这个变化，但修改要保持二叉搜索树性质的成立。
插入：
边界条件，二叉搜索树没有元素；否则找到新插入节点z插入的位置的双亲节点。
插入
删除：
三种基本策略：

z没有孩子节点，就只是简单的将它删除，并修改它的父节点，用NIL作为孩子来替换z。
如果z只有一个孩子，那么将这个孩子提升到树中z的位置上，并修改z的父节点，用z的孩子来替换z。
如果z有两个孩子，那么找z的后继y(一定在z的右子树中），并让y占据树中z的位置。z的原来右子树部分成为y的新的右子树，并且z的左子树成为y的新的左子树，这种情况稍显麻烦，因为还与y是否为z的右孩子相关。
删除算法
以v为根节点的子树替换以u为根节点的子树
随机构建二叉搜索树
略
BST(binary search tree)的基本操作大都能在O(h)时间内完成。

## 红黑树(red-black tree)
红黑树是许多平衡搜索树中的一点，可以保证最坏情况下基本动态集合操作的时间复杂度为O(nlgn)。
红黑树是一颗二叉搜索树，增加了颜色，RED or BLACK，确保了没有一条路径会比其他路径长出2倍，因而是近似于平衡的。
相比BST的属性p,left,right,key多了一个属性color。
红黑树的一些特性：

每个节点是红色或是黑色
根节点是黑色的
每个叶节点（NIL）是黑色的
如果一个节点是红色的，则它的两个子节点都是黑色的
对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。
使用一个哨兵（sentinel）T.NIL代表所有的NIL
从某个节点x出发（不含该节点）到达一个叶节点的任意一条简单路径上的黑色节点个数称为该节点的黑高（black-height），记作bh(x)
### 旋转
进行增删的时候可能会破坏上面提到的5条性质，因此为了维护这些性质，必须改变某些节点的颜色及指针结构。
指针结构的修改是通过旋转（rotation）来完成的。
这里的左旋和右旋似乎跟《大话数据结构》里AVL树的左旋右旋有相似之处。
left-rotate(T,x)

## 插入
插入耗费时间O(lgN)，且该程序选择不超过两次
插入一个节点z，并将其着色为红色。
RB-INSERT(T,z)
插入后的修补工作：
RB-INSERT-FIXUP(T,z)
while的结束条件是当z的双亲节点颜色是黑色时
fixup例子：（阴影部分为黑色）
RB-INSERT-FIXUP
插入操作只可能破坏红黑树性质2和性质4，并且只能破坏其中一条。
修补的三种情况分析：
case 1：z的叔节点y是红色的
此时，不需要旋转，只需要改变颜色,z指向z.p.p即可
z.p.color = y.color = black;
z.p.p.color = red;
case1
case2：z的叔节点y是黑色的且z是一个右孩子
case3：z的叔节点y是黑色的且z是一个左孩子
情况2通过一次左旋转成case3。
z.p.color = black;
z.p.p.color=red;
再一次右旋
case2和case3

### 删除
删除节点耗费O(lgN）时间。
需要提供一个让某节点孩子来接替老子位置的一个方法transplant
RB-TRANSPLANT(T,u,v)
删除方法：
RB-DELETE(T,z)
1-8行是子承父位，9行是找出z的后继,10-20行维护了相关的一些指针指向（将y的右孩子移到y的位置，y移到z的位置），21-22行如果z孩子小于2个，z的颜色是黑色（这种情况很简单，结合红黑树性质5分析）或者z孩子有两个，z的后继是黑色，则进行修正（画图理解最清楚了，比较简单就不画了）。为什么修正呢，因为当是黑色的时候，会破坏红黑树性质5，影响黑高。
来看下删除修复过程：
RB-DELETE-FIXUP(T,x)
删除修复例子：
删除修复例子
删除的四种case：
case1：x的兄弟节点w是红色的
过程：w描黑，x.p描红，x.p左旋，维持w兄弟指针指向
case2：x的兄弟节点w是黑色的，w的两个子节点都是黑色的
w描红，x指向x.p
case3：x的兄弟节点w是黑色的，w的孩子左红右黑
w左孩子描黑，w描红，w右旋，w指向x.p.right，仍旧是维持兄弟指针指向
case4：x的兄弟节点w是黑色的，w的右孩子是红色的
修改w颜色同x.p颜色一致，x.p描黑，w右孩子描黑，结束循环。
关于删除的一些深入理解，参考图解红黑树（别看评论，笑点低的会觉得搞笑的_）
了解了散列（hash）和红黑树，就可以去愉快的看下Java里面HashMap的源码啦。

AVL（树）
节点左右子树高度相差至多为1.
未深入讲解。

B树
为磁盘存储而专门设计的一类平衡搜索树。B树类似于红黑树，但它们在降低磁盘I/O操作数方面要更好一些，许多数据库系统使用B树或者B树变种来存储信息。比如MySQL数据库使用了B+树的数据结构。
B+相比B树来说，主要有几个区别，B+树叶子节点存储了所有数据，可以只经过一次遍历；叶子节点构成了一个单向链表。至于B树的插入删除等，参考2-3树更容易理解一些。
关于B树和B+树的区别等可以参加B树和B+树的区别

B-tree，B+tree，想起以前还以为是一个B+，一个B-呢，

辅存上的数据结构
计算机的主存（primary memory或main memory）通常由硅存储芯片组成。相比辅存比如磁盘磁带价格高，容量小，而辅存容量大价格低然而速度也要慢一些。（这方面的知识哪天还得看下计算机组成原理，虽然《计算机科学导论》也讲过一些，但总觉得还差点东西）
磁盘驱动器
磁盘慢，主要是因为有机械运动的部分：盘片旋转和磁臂移动。
本书第三版，2009年出版，这时磁盘旋转速度是5400~15000转/分钟（RPM），通常15000RPM的速度是用于服务器级的驱动器上，7200RPM的速度用于台式机的驱动器上，5400RPM的速度用于笔记本的驱动器上。随便在jd上看了机械硬盘和固态硬盘，机械硬盘缓存64MB左右，一款三星SSD缓存在512MB，读写在百兆/s。
7200RPM旋转一圈需要8.33ms，比硅存储的常见存取时间50ns要高出5个数量级（10的5次方）。也就是说，这个时间内，可能存取主存超过100000次。
为了瘫痪机械移动所花费的等待时间，磁盘会一次存取多个数据项而不是一个。信息被分为一系列相等大小的在柱面内连续出现的位页面（page），并且每个磁盘读或写一个或多个完整的页面。对于一个典型的磁盘来说，一夜的长度可能为211~214字节。
这里，对运行时间的两个主要组成成分分别加以考虑：磁盘存取次数和CPU（计算）时间。

### 定义
所有叶节点深度相同，即树高h；每个节点所包含的关键字个数有上界和下界，用一个被称为B树的最小度数的固定证书t≥2来表示这些界：每个节点除根节点外必须至少有t-1个关键字，至多可以包含2t-1个关键字。
B+tree将卫星数据存储到叶节点上，内部结点只存放关键字和孩子指针。对存储在磁盘上的一颗大的B树，通常看到分支因子在50~2000之间。

### 基本操作
约定：1. B树的根节点始终在主存中，这样无需对根做DISK-READ操作；然而，当根节点被改变后，需要对根节点做一次DISK-WRITE操作。2. 任何被当做参数的节点在被传递之前，都要对他们先做一次DISK-READ操作。

### 搜索B树
B-TREE-SEARCH(x,k)
先从x节点内部关键字查找，找不到，并且x有孩子的话或不是叶节点，再从x.ci孩子节点查找。

向B树中插入一个关键字
由于不能向满的叶节点插入节点，故引用分裂操作，将满的叶节点（2t-1）分割为两个（t-1)关键字的节点，中间关键字被提升到y的父节点。从树根往下查找关键字所属位置时，就分裂沿途遇到的每一个满节点。

分裂B树中的节点
分裂是树长高的唯一途径。
B-TREE-SPLIT-CHILD(x,i)
以沿树单程下行方式向B树插入关键字
B-TREE-INSERT(T,k)
B-TREE-INSERT-NONFULL(x,k)
2-8行处理x是叶节点的情况，9-12行找到合适的位置，如果ci子节点已满，则进行split操作，15-16行确定应该具体插入那个ci节点，17行递归插入。
这里提到一点，insert-nonfull是尾递归的，所以它可以用一个while循环来实现（这里也是一个重要的知识点，改天再找资料尝试一下）
图解插入：
插入实例

从B树中删除关键字
根节点允许有比最少关键字数t-1还少的关键字个数。
当要删除关键字的路径上节点（非根）有最少的关键字个数时，也可能需要向上回溯。
删除实例：
删除关键字
删除比较复杂一点，case1,case2a,2b,2c,case3a,3b.
递归调用自身时，必须保证该节点至少有t个关键字
高级设计和分析技术
动态规划（dynamic programming）
这里，programming指的是一种表格法，并非编写计算机程序
动态规划方法通常用来求解最优化问题（optimization problem）
似乎跟高中学习的求最优解的问题有相似之处。
按如下4个步骤来设计动态规划算法：

刻画出一个最优解的结构特征
递归的定义最优解的值
计算最优解的值，通常采用自底向上的方法
利用计算出的信息构造一个最优解
最优子结构（optimal substructure）性质：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解，主要原因是：反复求解相同的子问题，同斐波那契数列基本递归一样。
动态规划方法仔细安排求解顺序，对每个子问题只求解一次，并将结果保存下来。此乃时空权衡（time-memory-trade-off）。

自顶向下递归实现：时间复杂度(2^n)
CUT-ROD(p,n)
动态规划有两种等价的实现方法：

带备忘的自顶向下法（top-down with memoization）
仍按自然递归形式编写过程，但过程会保存每个子问题的解（通常保存在一个数组或散列表中）
