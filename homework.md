# 回溯法
## 一. 回溯法 – 深度优先搜素
### 1. 简单概述
       回溯法思路的简单描述是：把问题的解空间转化成了图或者树的结构表示，然后使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。
基本思想类同于：
图的深度优先搜索
二叉树的后序遍历
分支限界法：广度优先搜索
思想类同于：图的广度优先遍历
二叉树的层序遍历
### 2. 详细描述
        详细的描述则为：
        回溯法按深度优先策略搜索问题的解空间树。首先从根节点出发搜索解空间树，当算法搜索至解空间树的某一节点时，先利用剪枝函数判断该节点是否可行（即能得到问题的解）。如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。
        回溯法的基本行为是搜索，搜索过程使用剪枝函数来为了避免无效的搜索。剪枝函数包括两类：1. 使用约束函数，剪去不满足约束条件的路径；2.使用限界函数，剪去不能得到最优解的路径。
        问题的关键在于如何定义问题的解空间，转化成树（即解空间树）。解空间树分为两种：子集树和排列树。两种在算法结构和思路上大体相同。
### 3. 回溯法应用
       当问题是要求满足某种性质（约束条件）的所有解或最优解时，往往使用回溯法。
       它有“通用解题法”之美誉。
## 二. 回溯法实现 - 递归和递推（迭代）
        回溯法的实现方法有两种：递归和递推（也称迭代）。一般来说，一个问题两种方法都可以实现，只是在算法效率和设计复杂度上有区别。
      【类比于图深度遍历的递归实现和非递归（递推）实现】
1. 递归
2. 递推
      算法设计相对复杂，但效率高。
## 三. 子集树和排列树
1. 子集树
       所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间成为子集树。
如0-1背包问题，从所给重量、价值不同的物品中挑选几个物品放入背包，使得在满足背包不超重的情况下，背包内物品价值最大。它的解空间就是一个典型的子集树。
## 四. 经典问题
（1）装载问题
（2）0-1背包问题
（3）旅行售货员问题
（4）八皇后问题
（5）迷宫问题
（6）图的m着色问题
1. 0-1背包问题
        问题：给定n种物品和一背包。物品i的重量是wi，其价值为pi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?
        分析：问题是n个物品中选择部分物品，可知，问题的解空间是子集树。比如物品数目n=3时，其解空间树如下图，边为1代表选择该物品，边为0代表不选择该物品。使用x[i]表示物品i是否放入背包，x[i]=0表示不放，x[i]=1表示放入。回溯搜索过程，如果来到了叶子节点，表示一条搜索路径结束，如果该路径上存在更优的解，则保存下来。如果不是叶子节点，是中点的节点（如B），就遍历其子节点（D和E），如果子节点满足剪枝条件，就继续回溯搜索子节点。
2. 旅行售货员问题
      回溯法----旅行售货员问题
3. 详细描述N皇后问题
       问题：在n×n格的棋盘上放置彼此不受攻击的n个皇后。按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
       N皇后问题等价于在n×n格的棋盘上放置n个皇后，任何2个皇后不放在同一行或同一列或同一斜线上。
      分析：从n×n个格子中选择n个格子摆放皇后。可见解空间树为子集树。
      使用Board[N][N]来表示棋盘，Board[i][j]=0 表示(I,j)位置为空，Board[i][j]=1 表示(I,j)位置摆放有一个皇后。
      全局变量way表示总共的摆放方法数目。
      使用Queen(t)来摆放第t个皇后。Queen(t) 函数符合子集树时的递归回溯范式。当t>N时，说明所有皇后都已经摆   放完成，这是一个可行的摆放方法，输出结果；否则，遍历棋盘，找皇后t所有可行的摆放位置，Feasible(i,j) 判断皇后t能否摆放在位置(i,j)处，如果可以摆放则继续递归摆放皇后t+1，如果不能摆放，则判断下一个位置。
       Feasible(row,col)函数首先判断位置(row,col)是否合法，继而判断(row,col)处是否已有皇后，有则冲突，返回0，无则继续判断行、列、斜方向是否冲突。斜方向分为左上角、左下角、右上角、右下角四个方向，每次从（row,col）向四个方向延伸一个格子，判断是否冲突。如果所有方向都没有冲突，则返回1，表示此位置可以摆放一个皇后。
PS：该问题还有更优的解法。充分利用问题隐藏的约束条件：每个皇后必然在不同的行(列)，每个行(列)必然也只有一个皇后。这样我们就可以把N个皇后放到N个行中，使用Pos[i]表示皇后i在i行中的位置（也就是列号）（i = 0 to N-1）。这样代码会大大的简洁，因为节点的子节点数目会减少，判断冲突也更简单。
### 4. 迷宫问题
        问题：给定一个迷宫，找到从入口到出口的所有可行路径，并给出其中最短的路径
        分析：用二维数组来表示迷宫，则走迷宫问题用回溯法解决的的思想类似于图的深度遍历。从入口开始，选择下一个可以走的位置，如果位置可走，则继续往前，如果位置不可走，则返回上一个位置，重新选择另一个位置作为下一步位置。
        N表示迷宫的大小，使用Maze[N][N]表示迷宫，值为0表示通道（可走），值为1表示不可走（墙或者已走过）；
       1. 首先将当前点加入路径，并设置为已走
       2. 判断当前点是否为出口，是则输出路径，保存结果；跳转到4
       3. 依次判断当前点的上、下、左、右四个点是否可走，如果可走则递归走该点
       4. 当前点推出路径，设置为可走
