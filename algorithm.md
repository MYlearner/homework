# 算法导论
##  第一章：算法在计算机中的作用
　　本章是本书的开篇，介绍了什么是算法，为什么要学习算法，算法在计算机中的地位及作用。
　　算法（algorithm）简单来说就是定义良好的计算机过程，它取一个或一组值作为输入，并产生出一个或一组值作为输出。即算法就是一系列的计算步骤，用来将输入数据转换成输出数据。
## 第二章：算法入门

本章通过介绍插入排序和归并排序两种常见的排序算法来说明算法的过程及算法分析，在介绍归并排序算法过程中引入了分治（divide-and-conquer）算法策略。
1、插入排序
　　输入：n个数（a1,a2,a3,...,an）
　　输出：输入序列的一个排列（a1',a2',a3',...an'）使得（a1'≤a2'≤a3'≤...≤an'）。
　　插入排序的基本思想是：将第i个元素插入到前面i-1个已经有序的元素中。具体实现是从第2个元素开始（因为1个元素是有序的），将第2个元素插入到前面的1个元素中，构成两个有序的序列，然后从第3个元素开始，循环操作，直到把第n元素插入到前面n-1个元素中，最终使得n个元素是有序的。该算法设计的方法是增量方法。书中给出了插入排序的为代码，并采用循环不变式证明算法的正确性。
2、归并排序
　　归并排序采用了算法设计中的分治法，分治法的思想是将原问题分解成n个规模较小而结构与原问题相似的小问题，递归的解决这些子问题，然后再去合并其结果，得到原问题的解。分治模式在每一层递归上有三个步骤：
分解（divide）：将原问题分解成一系列子问题。
解决（conquer）：递归地解答各子问题，若子问题足够小，则直接求解。
合并（combine）：将子问题的结果合并成原问题的解。
归并排序（merge sort）算法按照分治模式，操作如下：
分解：将n个元素分解成各含n/2个元素的子序列
解决：用合并排序法对两个序列递归地排序
合并：合并两个已排序的子序列以得到排序结果

　　在对子序列排序时，长度为1时递归结束，单个元素被视为已排序好的。归并排序的关键步骤在于合并步骤中的合并两个已经有序的子序列，引入了一个辅助过程，merge(A,p,q,r)，将已经有序的子数组A[p...q]和A[q+1...r]合并成为有序的A[p...r]。书中给出了采用哨兵实现merge的伪代码，课后习题要求不使用哨兵实现merge过程。在这个两种方法中都需要引入额外的辅助空间，用来存放即将合并的有序子数组，总的空间大小为n。

## 归并排序算法分析：

　　算法中含有对其自身的递归调用，其运行时间可以用一个递归方程（或递归式）来表示。归并排序算法分析采用递归树进行，递归树的层数为lgn+1，每一层的时间代价是cn，整棵树的代价是cn(lgn+1)=cnlgn+cn，忽略低阶和常量c，得到结果为θ(nlg n)。
3、课后习题
(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。    
(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。  
  
(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。  
  
(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。  
  
一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。  
  
实际应用中可以按以下几个简化的步骤进行设计：  
  （1）分析最优解的性质，并刻画其结构特征。  
（2）递归的定义最优解。  
（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值。    
（4）根据计算优值时得到的信息，构造问题的最优解。
 - 方法1：要求运行时间为θ（nlgn），对于集合S中任意一个整数a，设b=x-a，采用二分查找算法在S集合中查找b是否存在，如果b存在说明集合S中存在两个整数其和等于x。而二分查找算起的前提是集合S是有序的，算法时间为θ（lgn），因此先需要采用一种时间最多为θ(nlgn)的算法对集合S进行排序。可以采用归并排序算法，这样总的运行时间为θ（nlgn），满足题目给定的条件。

具体实现步骤：

1、采用归并排序算法对集合S进行排序

2、对集合S中任意整数a，b=x-a，采用二分查找算法b是否在集合S中，若在则集合S中存在两个整数其和等于x，如果遍历了S中所有的元素，没能找到b，即集合S中不存在两个整数其和等于x。
## 第三章：函数的增长
　　本章介绍了算法分析中的渐进分析符号，几个重要渐进记号的定义如下：

Θ(g(n))={ f(n): 存在正常数c1,c2和n0，使对所有的n>=n0，有0<=c1g(n)<=f(n)<=c2g(n) }

O(g(n))={ f(n): 存在正常数c和n0，使对所有n>=n0，有0<=f(n)<=cg(n) }

Ω(g(n))={ f(n): 存在正常数c和n0，使对所有n>=n0，有0<=cg(n)<=f(n) }

o(g(n))={ f(n): 对任意正常数c，存在常数n0>0，使对所有的n>=n0，有0<=f(n)<=cg(n) }

ω(g(n))={ f(n): 对任意正常数c，存在常数n0>0，使对所有的n>=n0，有0<=cg(n)<f(n) }

f(n)=Ω(g(n))，表示这个算法是有一个渐近下界的，这个渐近下界为g(n)，算法的运行时间f(n)趋近并大于等于这个g(n)。

f(n)=Θ(g(n))，表示这个算法是有一个渐近确界的，这个渐近确界为g(n)，算法的运行时间f(n)趋近g(n)。

f(n)=O(g(n))，表示这个算法是有一个渐近上界的，这个渐近上界为g(n)，算法的运行时间f(n)趋近并小于等于这个g(n)。
