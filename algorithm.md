# 算法导论
##  1：最小生成树
1.Kruskal算法  
此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。  
1. 把图中的所有边按代价从小到大排序；  
2. 把图中的n个顶点看成独立的n棵树组成的森林；  
3. 按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。  
4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。  
  
2.Prim算法  
此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。  
  
图的所有顶点集合为VV；初始令集合u={s},v=V−uu={s},v=V−u;  
在两个集合u,vu,v能够组成的边中，选择一条代价最小的边(u0,v0)(u0,v0)，加入到最小生成树中，并把v0v0并入到集合u中。  
重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。  
由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组closedge,用来维护集合v中每个顶点与集合u中最小代价边信息，：
## 2：最短路径
1.迪杰斯特拉算法（Dijkstra算法）  
2.弗洛伊德算法（Floyd算法）  
1、Dijkstra算法介绍  
算法特点：  
  
迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。  
  
算法的思路  
  
Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。  
然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，  
然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。  
然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。
2.和Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名  
弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径  
迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。  
弗洛伊德算法VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。

## 3：DFS与BFS
搜索，简单狭窄地讲，就分为DFS与BFS，但是也有一些拓展的比如迭代深搜和IDA*搜索等等，搜索可以说是最基础却又是应用最广泛的算法。本文简单地总结下基础搜索在给定的显式图中的应用。  
 
搜索与DP，贪心，分治的共同点在于状态的转移，只不过在搜索中，一个阶段的最优状态是由之前所有状态得到的，这是其余其他算法的区别之处。  
  
状态的转移即由某一个不同的状态转移至另一个不同的状态，DFS在于从一个初始状态出发，一直转移状态直到搜到目标或搜到状态无法进行转移为止，其中的剪枝便是通过应题目具体要求和仔细分析而去掉某些没必要或不存在的状态以节约时间和空间，而BFS在于一层一层地扩展状态,这样首先找到的目标便一定是用时或步数最少的。DFS几乎适用于所有情况，因为这本身是一种遍历所有状态的搜索，只不过在寻找最小步或最小时间的情况下比较慢，无法快速找到目标，但在程序世界里DFS本身也有不适用的情况，如果状态没有下限即转移的深度没有下限那么便无法深搜，同样，BFS也可能存在一层状态都扩展不完的情况，这样便才会有迭代加深搜索等扩展搜索的出现，它结合了两者的优点且实际应用效果不错。紫书上面的名词“解答树”便很好地描述了所有状态转移的过程，当然这个似乎与我们无关，但是其实也是一种刻画搜索过程的有利工具。
## 4：动态规划

　　一般来说，只要问题可以划分为规模更小的字问题，并且原问题的最优解中包含了子问题的最优解，则可以考虑用动态规划解决。动态规划的实质是分治思想和解决冗余。因此，动态规划是一种将问题实例分解为更小的/相似的子问题，并存储子问题的解，使得每个子问题只求解一次，最终获得原问题的答案，以解决最优化问题的算法策略。
